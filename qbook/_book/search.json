[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introductory and intermediate data science for the bio/medical sciences using python",
    "section": "",
    "text": "This is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "This is a book for the Data Science for Bio/Biostat/Public Health/medical classes."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "intro.html#markdown",
    "href": "intro.html#markdown",
    "title": "Introduction",
    "section": "Markdown",
    "text": "Markdown\nBefore getting started, you need to learn some markdown. Markdown is a markup language (like HTML) that is absurdly easy. Every data scientist needs to know markdown. Fortunately, you’re five minutes away from knowing it. A markdown file is a text file that needs to be rendered to look nice. If you want an example, this page was written in markdown. To try it, go to google colab or a jupyter lab, create a markdown cell and start editing. Try this cheat sheet."
  },
  {
    "objectID": "intro.html#some-basic-unix",
    "href": "intro.html#some-basic-unix",
    "title": "Introduction",
    "section": "Some basic unix",
    "text": "Some basic unix\nSome basic unix commands will go a long way in the course, especially for when you’re working on a remote server. On windows, you can actually install a unix environment on so-called services for unix. So, on windows, you have three options for working with the command line, i) install a linux subsystem and use that, ii) use the DOS command prompt or iii) use powershell. The commands here would only work for option i. However, when I work on a windows system, I tend to just use options ii or iii. Here, we’ll assume you’re working on a linux or unix system, or windows services for linux and you’ll have to read up elsewhere if you want to learn windows proper terminal commands.\nTo get a unix terminal, you have several options. Since we’re promoting jupyter and jupyterlab, just open up the terminal on there. (Again, assuming you’re working on a unix/linux system.)\nThe first thing you should try is figuring out where you’re at. Do this by typing\nprompt> pwd\nThis will show you where you are in the directory structure. If you want to see the contents of the directory try these\nprompt> ls\nprompt> ls -al\nprompt> ls -alh\nAdding the flags -a lists everything, including directories with a weird character in front. The l gives the long format, which gives more information and the h changes the filesize lists to a more human readable format. I also like the option --color. What you get with-alh` is as follows.\ntotal 36K\ndrwxrwxrwx+ 7 codespace root      4.0K Feb 14 14:24 .\ndrwxr-xrwx+ 5 codespace root      4.0K Oct 19 15:21 ..\ndrwxrwxrwx+ 6 codespace codespace 4.0K Feb 14 14:31 book\ndrwxrwxrwx+ 8 codespace root      4.0K Feb 15 21:34 .git\n-rw-rw-rw-  1 codespace codespace  171 Feb 14 14:24 .gitignore\n-rw-rw-rw-  1 codespace codespace    0 Feb 14 14:23 .nojekyll\n-rw-rw-rw-  1 codespace codespace  444 Feb 14 14:24 README.md\ndrwxrwxrwx+ 3 codespace codespace 4.0K Feb 14 14:24 slides\ndrwxrwxrwx+ 7 codespace codespace 4.0K Oct 19 15:21 .venv\ndrwxrwxrwx+ 2 codespace codespace 4.0K Oct 19 15:23 .vscode\nThe drwxrwxrwx+1 looking columns give permissions d=directory, r=read, w=write and x=execute, the groups are owner (you), group, everyone. So a file that is -rw------- can be read and written to by the owner, but cannot be executed by anyone and no one else can read or write to it (except the superuser, who gets to do everything).\nTo change a directory, try the following\nprompt> cd DIRECTORY\nwhere DIRECTORY is the name of the directory that you want to change into. You can hit TAB to autocomplete names. The command\nprompt> mv PATH_TO_INPUT_FILE PATH_TO_OUTPUT_FILE\nmoves the file. This is also how you rename a file, since you could just do mv FILENAME1 FILENAME2 and change the name.\nThe unix command for removing things is rm. So\nrm FILENAME\ndeletes the file. Note linux really deletes things, so do this with some care. You can’t remove directories this way, instead you could do rmdir DIRECTORY, but the directory has to be empty. If you want to use rm to remove a directory and its contents, you can do rm -rf DIRECTORY. However, use this with care.\nFinally, I find it very useful to use wget to grab files from the internet. So, for example,\nwget https://URL.../FILENAME\nwill grab the file from that link. Super useful.\nThat’s enough unix to get you started. You’ll find as you use the terminal more and more, you’ll like it better and better. Eventually, you’ll find GUIs kind of frustrating."
  },
  {
    "objectID": "git.html",
    "href": "git.html",
    "title": "3  Git, github",
    "section": "",
    "text": "In the live versions of these classes, we use the version control system git and git hosting service github. If you work in data science should have a working knowledge of both git and at least one cloud hosting service (like github). For git, you work in a repository, which is basically a project directory on your computer with some extra files that help git work. Git is then used for version control so that you keep track of states of your project. Github, is a hosting service for git repositories. Typically, you have your repository on your computer and you coordinate it with the one on the server. Github is just one of several hosting services, bitbucket is another, or you could even relatively easily start your own. However, github has front end web services that allows you to interact with your remote repository easily. This is very convenient."
  },
  {
    "objectID": "git.html#the-least-you-need-to-know",
    "href": "git.html#the-least-you-need-to-know",
    "title": "3  Git, github",
    "section": "3.1 The least you need to know",
    "text": "3.1 The least you need to know\nI’m not going to fully recreate git / github tutorials here; here’s one I recommend by Sean Kross. Instead, I’m going to go through a typical git / github workflow.\n\nInitialization I almost always initialize my git repository on github with a readme.md file.\nClone I typically clone the repository to my local computer using the command line or a local git gui that works with github, like this one. Note that you only have to clone the repo once. After it’s cloned you have a full local copy of the repository.\nadd new files to track and stage them after I’ve worked with them.\ncommit the changes to the local repository with a meaningful commit message.\npush the changes to the repository.\nIf there’s changes on the remote repository not represented in my local repository, I pull those changes to my local repo.\n\nFor larger projects, you’re likely working with multiple people, some of whom you’ve given access to your remote repository and some of whom you have not. The ones who can’t directly push to the remote repo might have their own version of the code and their own version on github. If they think you should incorporate those changes, they might issue a pull request to you. You can then opt to pull their changes into your repo on github, then pull them from github to your local repo. One of the reasons why services like github and bitbucket are so popular is that they make this coordination fairly easy, along with having nice project messaging and management tools.\nIn our class, we use github classroom. For github classroom, you’ll get a link to a repo to put your submission files into. When you push to the remote repository, you’ll have submitted. But, up to the due date you can make changes an push again."
  },
  {
    "objectID": "git.html#a-little-more-detail",
    "href": "git.html#a-little-more-detail",
    "title": "3  Git, github",
    "section": "3.2 A little more detail",
    "text": "3.2 A little more detail\n\n3.2.1 Getting started\nGit is a version control system invented by Linus Torvalds, the invetor of the linux operating system. A github repository is a directory that the software git is using to keep track of versions. Install git, it’s already installed on most cloud services and many operaiting systems. You can initialize a repository in a directory with the command git init in that directory. Honestly, I almost never start a git repo this way, because I’ve connected my repo to a cloud server. But, more on that later. After you’ve initialized it, your git repo is a locally version controlled system.\n\n\n3.2.2 Adding files\nOK, now you want to add some of your files to your repo. You have a directory You can add files with the command\ngit add FILENAME\nThe file FILENAME is now staged to be part of the repository, but isn’t added yet! Files that you haven’t added won’t be tracked. This is good, since there’s many files, llike log files, that we don’t want to track. You only need to add the files once, then they are being tracked. Try it out with a readme markdown file in your repository.\n\n\n3.2.3 Checking status\nOne of the most useful git commands is\ngit status\nThis gives the status of which files are being tracked, which are not and which have changes.\n\n\n3.2.4 Commiting changes\nYou have to actually commit your changes to the repository to have them represented. Committing changes is a local operation, subsequently, we’ll show you how to coordinate with a remote repository. Here’s the command I use to commit most often\ngit commit -a -m \"COMMIT MESSAGE\"\nHere the flag -a means commit all files staged for commits. You can also commit individual files or a collection of specific files. The -m \"COMMIT MESSAGE\" is the message associated with your commit. Make your commit messages more informative. If you don’t add -m github will bring up an editor for you to enter your commit message.\n\n\n3.2.5 Remote repositories\nGit becomes much more useful when it’s coordinated with a remote repository. Github is a server for hosting remote git repositories, there are several others, bitbucket is an example. Github also includes a great deal of functionality for working with the remote repository through the website. There’s many git and github guis that you could use if you want. I always liked to github one and magit in emacs.\n\n3.2.5.1 Connecting your remote and local repos\nYou need to connect your local repo to the remote repo. First create a version of the repo on github (actually then it gives you instructions). Then you can either\n\nClone the repo from the server git clone REMOTE SERVER\nConnect the server to your local repository\n\nFor 2. you use a command like:\ngit remote add origin git@github.com:USERNAME/REPONAME.git\nPersonally, I find it easier just to create the repo on github and clone it. You can clone over ssh or https, if you don’t know what ssh is use https and then switch over to ssh as you learn how to use it.\n\n\n3.2.5.2 Pushing changes\n\nimport networkx as nx\nimport matplotlib.pyplot as plt\n#import numpy as np\n#import sklearn as skl\n\nplt.figure(figsize=[2, 2])\nG = nx.DiGraph()\n\nG.add_node(\"GH\",    pos = (.5, 1) )\nG.add_node(\"Local\", pos = (.5, 0))\n#G.add_edge(\"GH\", \"Local\")\nG.add_edge(\"Local\", \"GH\")\nnx.draw(G, \n        nx.get_node_attributes(G, 'pos'), \n        with_labels=True, \n        font_weight='bold', \n        node_size = 2000,\n        node_color = \"lightblue\",\n        linewidths = 3)\nax= plt.gca()\nax.collections[0].set_edgecolor(\"#000000\")\nax.set_xlim([-.3, 1.3])\nax.set_ylim([-.3, 1.3])\nplt.show()\n\n\n\n\nYou push from the repo you’re working on to another (remote repo). So, for me, this typically means pushing from my local computer repo to github or to a scientific computing cluster.\ngit push origin main\nThe above command could be read as “push my new committed changes from my origin to the main branch on my remote repo”. Older repos had the default branch master instead of main. But, github switched in 2020 or so. So, some older documentation may not have this switch.\n\n\n3.2.5.3 Pulling changes\n\nplt.figure(figsize=[2, 2])\nG = nx.DiGraph()\n\nG.add_node(\"GH\",    pos = (.5, 1) )\nG.add_node(\"Local\", pos = (.5, 0))\nG.add_edge(\"GH\", \"Local\")\n#G.add_edge(\"Local\", \"GH\")\nnx.draw(G, \n        nx.get_node_attributes(G, 'pos'), \n        with_labels=True, \n        font_weight='bold', \n        node_size = 2000,\n        node_color = \"lightblue\",\n        linewidths = 3)\nax= plt.gca()\nax.collections[0].set_edgecolor(\"#000000\")\nax.set_xlim([-.3, 1.3])\nax.set_ylim([-.3, 1.3])\nplt.show()\n\n\n\n\nThere might be changes that you want represented locally that were changed on the remote repository; for example, you might edit a readme file through github’s web interface. The command for this is really easy, it’s just pull\ngit pull\nThe pain occurs if you have made local changes that are in conflict with the remote changes. I’d write about merge conflicts, but I can’t, I just can’t (shudder). [Here’s some docs on managing merge conflicts] (https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/resolving-a-merge-conflict-using-the-command-line).\n\n\n3.2.5.4 Cloning\n\nplt.figure(figsize=[3, 2])\nG = nx.DiGraph()\n\nG.add_node(\"GH1\",    pos = (.5, 1) )\nG.add_node(\"Local1\", pos = (.5, 0))\nG.add_node(\"Local2\", pos = (1.5, 0))\n\nG.add_edge(\"GH1\", \"Local1\")\nG.add_edge(\"Local1\", \"GH1\")\nG.add_edge(\"GH1\", \"Local2\")\n\n#G.add_edge(\"Local\", \"GH\")\nnx.draw(G, \n        nx.get_node_attributes(G, 'pos'), \n        with_labels=True, \n        font_weight='bold', \n        node_size = 2500,\n        node_color = \"lightblue\",\n        linewidths = 3)\nax= plt.gca()\nax.collections[0].set_edgecolor(\"#000000\")\nax.set_xlim([-.3, 2.3])\nax.set_ylim([-.3, 1.3])\nplt.show()\n\n\n\n\nTo clone a remote repository is to simply create a local copy where you can pull changes from the remote. If a repository is public and you own it, then you can clone it and push changes back to the remote. If you don’t, you can clone and pull changes, but then can’t push back to the remote.\nTry with the book repo, clone it so you have access to the files. In the figure below the owner can pull and push to the repo. In the picture below, consider that you clone GH1 off of github to you. You can pull updates from GH1 but can’t push changes to GH1. The owner of GH1 of course can pull and push.\nAs an example, close this book (via https) with:\ngit clone https://github.com/smart-stats/ds4bio_book.git\n\n\n3.2.5.5 Forking\n\nplt.figure(figsize=[3, 2])\nG = nx.DiGraph()\n\nG.add_node(\"GH1\",    pos = (.5, 1) )\nG.add_node(\"GH2\",    pos = (1.5, 1) )\nG.add_node(\"Local1\", pos = (.5, 0))\nG.add_node(\"Local2\", pos = (1.5, 0))\n\nG.add_edge(\"GH1\", \"Local1\")\nG.add_edge(\"Local1\", \"GH1\")\nG.add_edge(\"GH1\", \"GH2\")\nG.add_edge(\"GH2\", \"Local2\")\nG.add_edge(\"Local2\", \"GH2\")\n\n\n#G.add_edge(\"Local\", \"GH\")\nnx.draw(G, \n        nx.get_node_attributes(G, 'pos'), \n        with_labels=True, \n        font_weight='bold', \n        node_size = 2500,\n        node_color = \"lightblue\",\n        linewidths = 3)\nax= plt.gca()\nax.collections[0].set_edgecolor(\"#000000\")\nax.set_xlim([-.3, 2.3])\nax.set_ylim([-.3, 1.3])\nplt.show()\n\n\n\n\nA common workflow for github is to “fork” the repository. This differs from cloning in the sense that your fork is an entirely separate new copy. In the picture above, GH2 is a fork of GH1. It can pull upstream changes from GH1, but can’t write to it, since you don’t own that repo. You can push and pull from Local2 which is connected to GH2.\nForking on github is easy. Just click the “fork” button in the upper right corner.\n\n\n3.2.5.6 Pull requests\n\nplt.figure(figsize=[3, 2])\nG = nx.DiGraph()\n\nG.add_node(\"GH1\",    pos = (.5, 1) )\nG.add_node(\"GH2\",    pos = (1.5, 1) )\nG.add_node(\"Local1\", pos = (.5, 0))\nG.add_node(\"Local2\", pos = (1.5, 0))\n\nG.add_edge(\"GH1\", \"Local1\")\nG.add_edge(\"Local1\", \"GH1\")\nG.add_edge(\"GH2\", \"GH1\")\nG.add_edge(\"GH2\", \"Local2\")\nG.add_edge(\"Local2\", \"GH2\")\n\n\n#G.add_edge(\"Local\", \"GH\")\nnx.draw(G, \n        nx.get_node_attributes(G, 'pos'), \n        with_labels=True, \n        font_weight='bold', \n        node_size = 2500,\n        node_color = \"lightblue\",\n        linewidths = 3)\nax= plt.gca()\nax.collections[0].set_edgecolor(\"#000000\")\nax.set_xlim([-.3, 2.3])\nax.set_ylim([-.3, 1.3])\nplt.show()\n\n\n\n\nImagine a case where you forked the book repo and have some great additions (maybe a section on merge conflicts?). You think that these changes you think should be represented for other students. You can’t push changes to my repo; the very idea would be perposterous! How do you get your great changes represented in my repo?\nYou issue a pull request in the sense of requesting GH1 to pull your changes from GH2. Then, I would get notified of the pull request and would decide whether or not to merge them into my repo. This system has many benefits, and particularly, is great for operating on open source projects.\nI like to do pull requests directly on github through the web interface."
  },
  {
    "objectID": "git.html#branching",
    "href": "git.html#branching",
    "title": "3  Git, github",
    "section": "3.3 Branching",
    "text": "3.3 Branching\nYou often want multiple versions of a repository. For example, you might want a development version, a working version and a stable version. This is what branches are for in git. To create and switch to a branch called dev, use:\ngit checkout -b dev\nThis creates a new branch called dev and switches to that branch. If you already have dev, use checkout without -b. Suppose you want to merge your change from dev into your default branch (main)\ngit checkout main\ngit merge dev\nStart very basic with branches, then when you get the hang of it you can use it like a pro. Here’s more documentation."
  },
  {
    "objectID": "git.html#clients",
    "href": "git.html#clients",
    "title": "3  Git, github",
    "section": "3.4 Clients",
    "text": "3.4 Clients\nYou can avoid the command line stuff with a git client, of which there are many. It’s still good to know the command line options, for remote work if nothing else. I’ve tried several git clients and my favorite is the github client software and magit in emacs."
  },
  {
    "objectID": "git.html#setting-up-ssh",
    "href": "git.html#setting-up-ssh",
    "title": "3  Git, github",
    "section": "3.5 Setting up ssh",
    "text": "3.5 Setting up ssh\nIf you want to connect to a remote repository to github on a unix or linux system, it’s probably easiest to set up using so called secure shell. You can also set it up a variety of ways on Windows, but the rules are a little less universal. If you find this very hard to follow, just use a git and github gui (like github desktop, which is what I like to recommend).\nSecure shell works as follows. It creates a public key (think like a lock, everyone can see it) and a private key (like the key for the lock, only you have it). When you connect to github, it has your public key and you use the private key to “unlock” it. First, you need a .ssh directory from your personal directory. If you don’t have that, try ssh username@server to a server that you know and it will automatically create one.\nwe’ll go through this tutorial.\nThen, cd into your .ssh director and type the following and follow the instructions\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\nThis generates your public/prviate key pair. Then you need to take the public key file, and upload it to github under settings. This is described here.\nIn some cases I’ve also had to add this to a file config in my .ssh directory:\nHost github.com\n     ForwardX11 no\n     HostName github.com\n     User git\n     IdentityFile ~/.ssh/YOUR_PRIVATE_KEY_FILENAME\nOnce this is setup, then you should be able to push and pull from github from the command line without passwords."
  },
  {
    "objectID": "git.html#github-pages",
    "href": "git.html#github-pages",
    "title": "3  Git, github",
    "section": "3.6 Github pages",
    "text": "3.6 Github pages\nIt’s possible to host web pages on github. By hosting I mean serving the web page on the internet so that others can view it. There’s a couple of steps to doing this. First, you need an html file to serve. If you look in the chapter on html, there’s the code for a basic wepage. Save a web page as say “index.html”. You can double check that it works by simply double clicking on the file on your local computer. It should display as a web page in your browser, but it’s only viewable by you. Notice the addres begins with file:///.... To serve the file so that others can view it, we need it to exist on a server.\nGithub will serve the file for us, but first we need a repository. Create a public repository; I typically do this on github. Then you need to add an empty file called .nojekyll. Don’t forget the period at the beginning. This prevents github from thinking you’re using the jekyll framework, which is the default. Since we’re serving a basic webpage, we don’t need this framework. I create this file on github just by clicking Add File then Create new file.\nNext we need to tell github that this repo serves web pages. Click on settings then pages on the left. Then, under source choose the branch that you want to serve the pages from. Add your html file, commit and push to github. Give it a few minutes, then your file will be served from\nhttps:///GITHUBUSERNAME.github.io/REPONAME/FILENAME.html\nwhere here GITHUBUSERNAME is either your github username or the organization. REPONAME is the name of your repository and FILENAME.html is your html file, with the path if it’s in subdirectories. As an example, here’s a version I did https://bcaffo.github.io/testHtmlRepo/index.html."
  },
  {
    "objectID": "markdown.html",
    "href": "markdown.html",
    "title": "1  Markdown",
    "section": "",
    "text": "Before getting started, you need to learn some markdown. Markdown is a markup language (like HTML) that is absurdly easy. Every data scientist needs to know markdown. Fortunately, you’re five minutes away from knowing it. A markdown file is a text file that needs to be rendered to look nice. If you want an example, this page was written in markdown. To try it, go to google colab or a jupyter lab, create a markdown cell and start editing. Try this cheat sheet."
  },
  {
    "objectID": "unix.html",
    "href": "unix.html",
    "title": "2  Unix",
    "section": "",
    "text": "Some basic unix commands will go a long way in the course, especially for when you’re working on a remote server. On windows, you can actually install a unix environment on so-called services for unix. So, on windows, you have three options for working with the command line, i) install a linux subsystem and use that, ii) use the DOS command prompt or iii) use powershell. The commands here would only work for option i. However, when I work on a windows system, I tend to just use options ii or iii. Here, we’ll assume you’re working on a linux or unix system, or windows services for linux and you’ll have to read up elsewhere if you want to learn windows proper terminal commands.\nTo get a unix terminal, you have several options. Since we’re promoting jupyter and jupyterlab, just open up the terminal on there. (Again, assuming you’re working on a unix/linux system.)\nThe first thing you should try is figuring out where you’re at. Do this by typing\nprompt> pwd\nThis will show you where you are in the directory structure. If you want to see the contents of the directory try these\nprompt> ls\nprompt> ls -al\nprompt> ls -alh\nAdding the flags -a lists everything, including directories with a weird character in front. The l gives the long format, which gives more information and the h changes the filesize lists to a more human readable format. I also like the option --color. What you get with-alh` is as follows.\ntotal 36K\ndrwxrwxrwx+ 7 codespace root      4.0K Feb 14 14:24 .\ndrwxr-xrwx+ 5 codespace root      4.0K Oct 19 15:21 ..\ndrwxrwxrwx+ 6 codespace codespace 4.0K Feb 14 14:31 book\ndrwxrwxrwx+ 8 codespace root      4.0K Feb 15 21:34 .git\n-rw-rw-rw-  1 codespace codespace  171 Feb 14 14:24 .gitignore\n-rw-rw-rw-  1 codespace codespace    0 Feb 14 14:23 .nojekyll\n-rw-rw-rw-  1 codespace codespace  444 Feb 14 14:24 README.md\ndrwxrwxrwx+ 3 codespace codespace 4.0K Feb 14 14:24 slides\ndrwxrwxrwx+ 7 codespace codespace 4.0K Oct 19 15:21 .venv\ndrwxrwxrwx+ 2 codespace codespace 4.0K Oct 19 15:23 .vscode\nThe drwxrwxrwx+1 looking columns give permissions d=directory, r=read, w=write and x=execute, the groups are owner (you), group, everyone. So a file that is -rw------- can be read and written to by the owner, but cannot be executed by anyone and no one else can read or write to it (except the superuser, who gets to do everything).\nTo change a directory, try the following\nprompt> cd DIRECTORY\nwhere DIRECTORY is the name of the directory that you want to change into. You can hit TAB to autocomplete names. The command\nprompt> mv PATH_TO_INPUT_FILE PATH_TO_OUTPUT_FILE\nmoves the file. This is also how you rename a file, since you could just do mv FILENAME1 FILENAME2 and change the name.\nThe unix command for removing things is rm. So\nrm FILENAME\ndeletes the file. Note linux really deletes things, so do this with some care. You can’t remove directories this way, instead you could do rmdir DIRECTORY, but the directory has to be empty. If you want to use rm to remove a directory and its contents, you can do rm -rf DIRECTORY. However, use this with care.\nFinally, I find it very useful to use wget to grab files from the internet. So, for example,\nwget https://URL.../FILENAME\nwill grab the file from that link. Super useful.\nThat’s enough unix to get you started. You’ll find as you use the terminal more and more, you’ll like it better and better. Eventually, you’ll find GUIs kind of frustrating."
  },
  {
    "objectID": "python.html",
    "href": "python.html",
    "title": "python background",
    "section": "",
    "text": "First, you’ll need a place to program python for data analysis. Python has a dizzying array of options for its use. A first choice is whether you’ll use python locally (installed on your computer) or in the cloud. The cloud options take care of a lot of installation problems, in exchange for a loss in control and typically much less computing resources unless you pay for stronger cloud computing. A second choice is whether you’ll look program in notebook environments or in a straight code editors. Notebooks mix code and documentation and are especially useful for programming for data analyses. More pure code editors and integrated development environments are preferable for writing software. Here’s a list of some of things I’ve tried and liked."
  },
  {
    "objectID": "python.html#notebooks",
    "href": "python.html#notebooks",
    "title": "python background",
    "section": "Notebooks",
    "text": "Notebooks\nNotebooks are going to be especially useful for us, as they’re a great way to do data analyses. With notebooks, you can merge richer documentation together with analysis code. You can take this to the extreme, and have solutions that create reproducible final documents. This book is an example, where the entire thing is written in jupyter-book. We’ll discuss this idea a little more when we discuss reproducible research. Alternatively, you can use your notebook as a working document that\nMost notebook solutions have text blocks and code blocks. The text is marked up in a markup language called “Markdown”, which we discussed eariler.\nIf you’re very new to notebooks in python, I would suggest starting with colab. The colab documentation is useful."
  },
  {
    "objectID": "python.html#weaved-text-formats",
    "href": "python.html#weaved-text-formats",
    "title": "python background",
    "section": "Weaved text formats",
    "text": "Weaved text formats\nI wrote this book in a format called quarto (see https://quarto.org/ ). This is a slightly different approach than jupyter notebooks and are perhaps better at producing final document-style output. Other approaches similar to quarto documents include R markdown, sweave and org mode."
  },
  {
    "objectID": "basic_python.html",
    "href": "basic_python.html",
    "title": "4  Python basics",
    "section": "",
    "text": "In this section, we will cover some basic python concepts. Python is an extremely quick language to learn, but like most programming languages, can take a long time to master. In this class, we’ll focus on a different style of programming than typical software development, programming with data. This will but less of a burden on us to be expert software developers in python, but some amount of base language knowledge is unavoidable. So, let’s get started learning some of the python programming basics. I’m going to assume you’ve programmed before in some language. If that isn’t the case, consider starting with a basic programming course of study before trying this book.\nA great resource for learning basic python is the python.org documentation https://docs.python.org/3/tutorial/index.html. My favorite programming resource of all time is the “Learn X in Y” tutorials. Here’s one for python https://learnxinyminutes.com/docs/python/.\nSome of the basic programming types in python are ints, floats, complex and Boolean. The command type tells us which. Here’s an example with 10 represented in 4 ways (int, float, string and complex) and the logical value True. Note, we’re using print to print out the result of the type command. If you’re typing directly into the python command line (called the repl, for read, evaluate, print, loop), you won’t need the print statements. But, if you’re using a notebook you probably will.\nIf you want an easy repl environment to program in, try https://replit.com/. For an easy notebook solution to try out, look at google colab, https://colab.research.google.com .\nThese types are our basic building blocks. There’s some other important basic types that build on these. We’ll cover these later, but to give you a teaser:\nTypes can be converted from one to another. For example, we might want to change our 10 into different types. Here’s some examples of converting the integer 10 into a float. First, we use the float function. Next we define a variable a that takes the integer value 10, then use a method associated with a to convert the type. If you’re unfamiliar with the second notation, don’t worry about that now, you’ll get very used to it as we work more in python.\nPython’s repl does all of the basic numerical calculations that you’d like. It does dynamic typing so that you can do things like add ints and floats. Here we show the basic operators, and note # is a comment in python.\nStrings are easy to work with in python. Type print(\"Hello World\") in the repl just to get that out of the way. Otherwise, + concatenates strings and brackets reference string elements. Here’s some examples. Remember counting starts at 0 and negative numbers count from the back.\nThe strings True and False are reserved for the respective Boolean values. The operators ==, >, <, >=, <= and != are the testing operators while and, or and is are Boolean operators. Here are some examples.\nDon’t define new variables called TRUE or FALSE or tRuE or FaLsE, or whatever, even though you can. Just get used to typing True and False the way python likes and don’t use similar named things for other reasons. Als, python as bitwise logical operators |, & and ~. On Boolean values, they work the same but differ in other circumstances. So, if you are unfamliar with bitwise operations, it’s probably better to stick to the word logical operators above."
  },
  {
    "objectID": "basic_python.html#data-structures",
    "href": "basic_python.html#data-structures",
    "title": "4  Python basics",
    "section": "4.1 Data structures",
    "text": "4.1 Data structures\nPython has some more advanced data structures that build on its primitive types.\n\nLists: ordered collections of objects\nSets: like lists but only have unique elements\nTuples: like lists, but not mutable, i.e. need to create a new one to modify\nDictionaries: named elements that you can reference by their name rather than position\n\nFirst, let’s look at some list operations.\n\ndat = [1, 4, 8, 10] # define a list\nprint(dat[0])       # reference an element\nprint(dat[2 : 4])   # reference elements\nprint(dat[2 : ]) \nprint(dat[:2])\ndat2 = [dat, dat]        # creating a list of lists\nprint(dat2)\nprint(dat2[1][2])        # referencing an item in a nested list\ndat3 = [dat2, \"string1\"] # mixed types\nprint(dat3)\ndat4 = dat + dat         # list concatenation\nprint(dat4)\n\n1\n[8, 10]\n[8, 10]\n[1, 4]\n[[1, 4, 8, 10], [1, 4, 8, 10]]\n8\n[[[1, 4, 8, 10], [1, 4, 8, 10]], 'string1']\n[1, 4, 8, 10, 1, 4, 8, 10]\n\n\nNow, let’s look at dictionaries.\n\ndict = {\"a\" : 1, \"b\" : 2} # Create a dictionary of two elements named a and b taking values 1 and 2 respectively\nprint(dict)\nprint(dict['a'])          # reference the element named a\n\n{'a': 1, 'b': 2}\n1\n\n\nSets and tuples are similar to lists, however with some important distinctions. Sets, contain only unique elements and tuples are immutable lists.\n\nset1 = {\"a\", \"b\", \"c\"}\nset2 = {\"a\", 1, True}\nset3 = {\"a\", \"b\", \"c\", \"c\"}\nprint(set1)\nprint(set2)\nprint(set3)\n\n{'b', 'a', 'c'}\n{1, 'a'}\n{'b', 'a', 'c'}\n\n\nHere’s an example to illustrate a tuple.\n\nlist1 = [\"a\", \"b\", \"c\"]\ntuple1 = (\"a\", \"b\", \"c\")\nlist1[0] = \"aa\" #Works just fine\nlist1\n#tuple1[0] = \"aa\" #doesn't work\n\n['aa', 'b', 'c']\n\n\n\n4.1.1 Mutable in immutable entities\nWhen working with objects in python, mutable and immutable elements act differently. Lists are mutable. So, below, the element y gets appended along with x.\n\nx = [10]\ny = x\nx.append(20)\n## Notice y has the appended element\nprint(y)\n## let's try again, as of now x = [10, 20] \nx[0] = x[0] + 11\n## Now x = [21, 20], but did y change?\nprint(y)\n\n[10, 20]\n[21, 20]\n\n\nThings like numbers and strings are immutable. Notice that changing y does not change x.\n\nx = 10\ny = x\nx = x + 10\nprint((x, y))\n\n(20, 10)"
  },
  {
    "objectID": "python_programming.html",
    "href": "python_programming.html",
    "title": "5  Python programming",
    "section": "",
    "text": "# do this if you'd like to prompt for an input\n# x = input(\"are you mean (y/n)? > \")\n# Let's just assume the user input 'n'\nx = 'n'\nif x == 'y': \n print(\"Slytherine!\")\nelse:\n print(\"Gryffindor\")\n\nGryffindor\n\n\nJust to further describe white space useage in python, consider testing whether statementA is True. Below, statementB is executed as part of the if statement whereas statementC is outside of it because it’s not indented. This is often considered an eye rolling aspect of the language, but I think it’s nice in the sense that it bakes good code identation practices into the language.\n## Some more about white space\nif statementA:\n  statementB   # Executed if statementA is True\nstatementC     # Executed regardless since it's not indented\nThe generic structure of if statements in python are\nif statement1 :\n ...\nelif statement2 :\n ...\nelse \n ...\nHere’s an example (note this is just equal to the statement (a < 0) - (a > 0)\n\na = 5\n\nif a < 0 :\n  a = -1\nelif a > 0 :\n  a = 1\nelse :\n  a = 0\n\nprint(a)\n\n1\n\n\nfor and while loops can be used for iteration. Here’s some examples\n\nfor i in range(4) :\n print(i)\n\n0\n1\n2\n3\n\n\n\nx = 4\nwhile x > 0 :\n x = x - 1\n print(x)\n\n3\n2\n1\n0\n\n\nNote for loops can iterate over list-like structures.\n\nfor w in 'word':\n print(w)\n\nw\no\nr\nd\n\n\nThe range function is useful for creating a structure to loop over. It creates a data type that can be iterated over, but isn’t itself a list. So if you want a list out of it, you have to convert it.\n\na = range(3)\nprint(a)\nprint(list(a))\n\nrange(0, 3)\n[0, 1, 2]"
  },
  {
    "objectID": "python_practice.html",
    "href": "python_practice.html",
    "title": "6  Python in practice",
    "section": "",
    "text": "The kind of programming we’ve seen so far in python isn’t how typical data programmming in python goes. Instead, we tend to rely a lot of modules that add methods to our complex data science objects. Most python objects are class objects that come with a variety of convenient methods associated with them. If you’re working in a good coding environment, then it should have some method autocompletion for your objects, which helps prevent typos and can speed up work. Let’s look at methods associated with a list object. Note that some methods change the object itself while others return things without changing the object.\nA useful working example is working with imaginary numbers.\nLet’s create our own version of a complex number, adapted from here. Complex numbers have two parts, the real part and the “imaginary” part. (Note I put imaginary in quotes, since, IMHO, complex numbers and the associated operations are simply an algebraic system, no more or less imaginary than most other algebraic systems. They simply lack the direct real world counting analogy of squaring a whole number. But there are countless algenbraic systems created for a variety of uses, most lacking the direct analogy to counting whole numbers.) There’s two popular representations of complex numbers, Cartesian and polar. We’ll use Cartesian and not discuss polar.\nA complex number is represented as \\(a + bi\\) where \\(a\\) and \\(b\\) are numbers and \\(i\\) is the symbol for the complex root of -1, i.e. \\(i^2 = -1\\). If $a + b i $ is a complex number, \\(a - bi\\) is its so-called conjugate. Conjugates are useful since \\[ (a+bi)(a-bi) = a^2 + abi -\nabi - b^2 i^2 = a^2 + b^2 \\]\nLet’s create an object called mycomplex and give it a conjugation method and some other stuff.\nLet’s now create a version that doesn’t modify the object when we conjugate."
  },
  {
    "objectID": "python_practice.html#utilizing-python-libraries",
    "href": "python_practice.html#utilizing-python-libraries",
    "title": "6  Python in practice",
    "section": "6.1 Utilizing python libraries",
    "text": "6.1 Utilizing python libraries\nWe typically load libraries that create useful data structures for us and have useful functions. We’ll use pandas a lot next. So, let’s go through another very useful data science library, numpy.\nFirst, let’s load up numpy. Here’s three separate ways\n\nimport numpy\nimport numpy as np\nfrom numpy import *\n\nOption 1. imports numpy, but then you have to type numpy.FUNCTION to access FUNCTION. The second option (my preferred) shortens this to np.FUNCTION. The third loads the numpy functions into the global namespace. This is probably ok for really core packages like numpy. But, otherwise it’s an issue since you typically load many libraries and some may have the same function names.\nLet’s load up numpy and look at some of its capabilities.\n\nimport numpy as np\n\n## Numpy has constants\nprint(np.pi)\n## Numpy has a not a number placeholder\nprint(np.nan)\n## Numpy has 1 and 2d arrays\nvector = np.array([1, 2, 3, 8])\nprint(vector)\nprint(type(vector))\n## Numpy has N-Dimensional arrays\narray = np.array([ [1, 2, 3], [4, 5, 6]])\nprint(array)\n\n3.141592653589793\nnan\n[1 2 3 8]\n<class 'numpy.ndarray'>\n[[1 2 3]\n [4 5 6]]\n\n\n\n## Arrays have operator definitions\nprint(array + array)\nprint(array * array)\n\n[[ 2  4  6]\n [ 8 10 12]]\n[[ 1  4  9]\n [16 25 36]]\n\n\nLet’s look at a common use of a library object. Our vector, vector, has some data in it. What if we wanted the mean and standard deviation?\n\nprint(vector.mean())\nprint(vector.std())\n\n3.5\n2.692582403567252\n\n\nNumpy has a separate data structure for matrices (2D arrays). Let’s creat a matrix like our previous 2D array.\n\nmymat = np.matrix([ [1, 2], [4, 5] ] )\nprint( (type(array), type(mymat) ) )\nmymat\n\n(<class 'numpy.ndarray'>, <class 'numpy.matrix'>)\n\n\nmatrix([[1, 2],\n        [4, 5]])\n\n\nNumpy’s linear algebra functions are spread across sublibraries of numpy. linalg is one. Let’s suppose we want the matrix determinant of mymat. We have several choices\n\nnp.linalg.det(mymat)\nimport numpy.linalg as la then la.det(mymat)\nfrom numpy.linalg import det then det(mymat)\n\nThe first is a little long, but just calls the sublibrary then the function of the sublibrary. The second and third are shorter, where the second gives a named reference to the sublibrary methods while the third loads the function into the namespace.\n\nfrom numpy.linalg import det \ndet(mymat)\n\n-2.9999999999999996\n\n\n\nx = np.array([1.1, 2.1, 3.1, 3.2, 8.6])\nx[1:3]\n\narray([2.1, 3.1])"
  },
  {
    "objectID": "python_practice.html#building-python-modules",
    "href": "python_practice.html#building-python-modules",
    "title": "6  Python in practice",
    "section": "6.2 Building python modules",
    "text": "6.2 Building python modules\nWith very small effort, a set of python functions can be turned into a python library. Let’s start with creating a python module, then we’ll talk about distributing with pip"
  },
  {
    "objectID": "python_practice.html#example-utilizing-python-libraries-numpy",
    "href": "python_practice.html#example-utilizing-python-libraries-numpy",
    "title": "6  Python in practice",
    "section": "6.1 Example utilizing python libraries, numpy",
    "text": "6.1 Example utilizing python libraries, numpy\nWe typically load libraries that create useful data structures for us and have useful functions. We’ll use pandas a lot next. So, let’s go through another very useful data science library, numpy.\nFirst, let’s load up numpy. Here’s three separate ways\n\nimport numpy\nimport numpy as np\nfrom numpy import *\n\nOption 1. imports numpy, but then you have to type numpy.FUNCTION to access FUNCTION. The second option (my preferred) shortens this to np.FUNCTION. The third loads the numpy functions into the global namespace. This is probably ok for really core packages like numpy. But, otherwise it’s an issue since you typically load many libraries and some may have the same function names.\nLet’s load up numpy and look at some of its capabilities.\n\nimport numpy as np\n\n## Numpy has constants\nprint(np.pi)\n## Numpy has a not a number placeholder\nprint(np.nan)\n## Numpy has 1 and 2d arrays\nvector = np.array([1, 2, 3, 8])\nprint(vector)\nprint(type(vector))\n## Numpy has N-Dimensional arrays\narray = np.array([ [1, 2, 3], [4, 5, 6]])\nprint(array)\n\n3.141592653589793\nnan\n[1 2 3 8]\n<class 'numpy.ndarray'>\n[[1 2 3]\n [4 5 6]]\n\n\n\n## Arrays have operator definitions\nprint(array + array)\nprint(array * array)\n\n[[ 2  4  6]\n [ 8 10 12]]\n[[ 1  4  9]\n [16 25 36]]\n\n\nLet’s look at a common use of a library object. Our vector, vector, has some data in it. What if we wanted the mean and standard deviation?\n\nprint(vector.mean())\nprint(vector.std())\n\n3.5\n2.692582403567252\n\n\nNumpy has a separate data structure for matrices (2D arrays). Let’s creat a matrix like our previous 2D array.\n\nmymat = np.matrix([ [1, 2], [4, 5] ] )\nprint( (type(array), type(mymat) ) )\nmymat\n\n(<class 'numpy.ndarray'>, <class 'numpy.matrix'>)\n\n\nmatrix([[1, 2],\n        [4, 5]])\n\n\nNumpy’s linear algebra functions are spread across sublibraries of numpy. linalg is one. Let’s suppose we want the matrix determinant of mymat. We have several choices\n\nnp.linalg.det(mymat)\nimport numpy.linalg as la then la.det(mymat)\nfrom numpy.linalg import det then det(mymat)\n\nThe first is a little long, but just calls the sublibrary then the function of the sublibrary. The second and third are shorter, where the second gives a named reference to the sublibrary methods while the third loads the function into the namespace.\n\nfrom numpy.linalg import det \ndet(mymat)\n\n-2.9999999999999996\n\n\n\nx = np.array([1.1, 2.1, 3.1, 3.2, 8.6])\nx[1:3]\n\narray([2.1, 3.1])"
  }
]